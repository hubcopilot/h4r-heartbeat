<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>H4R 3D Logo (Transparent)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    html, body { height: 100%; }
    body { margin: 0; background: transparent; overflow: hidden; }
    canvas { display: block; }
  </style>
</head>
<body>
<script type="module">
import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js";
import { FontLoader } from "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/loaders/FontLoader.js";
import { TextGeometry } from "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/geometries/TextGeometry.js";
import { CSG } from "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/geometry/CSG.js";
import TWEEN from "https://cdn.jsdelivr.net/npm/@tweenjs/tween.js@18.6.4/dist/tween.esm.js";

// ---------- Renderer (transparent) ----------
const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.setSize(innerWidth, innerHeight);
renderer.setClearColor(0x000000, 0); // fully transparent
document.body.appendChild(renderer.domElement);

// ---------- Scene & Camera ----------
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(60, innerWidth / innerHeight, 0.1, 1000);
camera.position.set(0, 0.8, 6);

// ---------- Lights (soft glossy look) ----------
scene.add(new THREE.AmbientLight(0xffbfdc, 0.7));
const key = new THREE.DirectionalLight(0xffffff, 1.2);
key.position.set(4, 5, 5);
scene.add(key);
const rim = new THREE.DirectionalLight(0xffffff, 0.6);
rim.position.set(-3, 2, -4);
scene.add(rim);

// ---------- Materials ----------
const heartMat = new THREE.MeshStandardMaterial({
  color: 0xff4f8b, metalness: 0.4, roughness: 0.3
});
const textMat = new THREE.MeshStandardMaterial({
  color: 0xffe3f2, metalness: 0.4, roughness: 0.2
});

// ---------- Heart Shape (utility) ----------
function makeHeartShape() {
  const s = new THREE.Shape();
  s.moveTo(0, 0);
  s.bezierCurveTo(0, 0, -1.2, -1.2, -2, 0);
  s.bezierCurveTo(-2, 1.2, 0, 2.5, 0, 3);
  s.bezierCurveTo(0, 2.5, 2, 1.2, 2, 0);
  s.bezierCurveTo(1.2, -1.2, 0, 0, 0, 0);
  return s;
}

// ---------- Big Heart (background) ----------
const bigHeartGeo = new THREE.ExtrudeGeometry(makeHeartShape(), {
  depth: 0.5,
  bevelEnabled: true,
  bevelThickness: 0.1,
  bevelSize: 0.1,
  bevelSegments: 5
});
const bigHeart = new THREE.Mesh(bigHeartGeo, heartMat);
bigHeart.rotation.x = Math.PI; // face camera
scene.add(bigHeart);

// Group core logo for easy transforms (big heart + text)
const coreGroup = new THREE.Group();
scene.add(coreGroup);
coreGroup.add(bigHeart);

// ---------- 3D Text "H4R" with heart cutout in R ----------
const fontLoader = new FontLoader();
fontLoader.load("assets/font/helvetiker_bold.typeface.json", (font) => {
  const textGeo = new TextGeometry("H4R", {
    font,
    size: 1,
    height: 0.3,
    curveSegments: 10,
    bevelEnabled: true,
    bevelThickness: 0.05,
    bevelSize: 0.05,
    bevelSegments: 6
  });
  const textMesh = new THREE.Mesh(textGeo, textMat);

  textGeo.computeBoundingBox();
  const xOffset = -0.5 * (textGeo.boundingBox.max.x - textGeo.boundingBox.min.x);
  textMesh.position.set(xOffset, 0.4, 0.3);
  textMesh.rotation.x = Math.PI;

  // Heart cutout (beveled) to subtract from R
  const cutShape = new THREE.Shape();
  cutShape.moveTo(0, 0.5);
  cutShape.bezierCurveTo(-0.35, 0.5, -0.65, 0.2, -0.65, -0.1);
  cutShape.bezierCurveTo(-0.65, -0.45, -0.3, -0.7, 0, -0.35);
  cutShape.bezierCurveTo(0.3, -0.7, 0.65, -0.45, 0.65, -0.1);
  cutShape.bezierCurveTo(0.65, 0.2, 0.35, 0.5, 0, 0.5);

  const cutGeo = new THREE.ExtrudeGeometry(cutShape, {
    depth: 0.4,
    bevelEnabled: true,
    bevelThickness: 0.05,
    bevelSize: 0.05,
    bevelSegments: 5
  });
  const cutMesh = new THREE.Mesh(cutGeo);
  // position over the "R"
  cutMesh.position.set(1.6, 0.55, 0.15);
  cutMesh.scale.set(0.35, 0.35, 0.35);
  cutMesh.rotation.x = Math.PI;

  // Carve heart hole into the text
  const textWithHole = CSG.subtract(textMesh, cutMesh);
  coreGroup.add(textWithHole);

  // ---------- Small Heart (animated) ----------
  const smallHeart = new THREE.Mesh(bigHeartGeo.clone(), heartMat.clone());
  smallHeart.scale.set(0.4, 0.4, 0.4);
  smallHeart.rotation.x = Math.PI;

  // Start offscreen-ish (top-right)
  smallHeart.position.set(3.0, 3.0, 0.3);
  scene.add(smallHeart);

  // Target position (corner of big heart)
  const targetPos = { x: 1.4, y: 1.8, z: 0.3 };

  function animateIn() {
    new TWEEN.Tween(smallHeart.position)
      .to(targetPos, 1500)
      .easing(TWEEN.Easing.Quadratic.Out)
      .onComplete(spinHeart)
      .start();
  }

  function spinHeart() {
    // 4 spins => 8Ï€ radians
    new TWEEN.Tween(smallHeart.rotation)
      .to({ z: smallHeart.rotation.z + Math.PI * 8 }, 6000)
      .easing(TWEEN.Easing.Quadratic.InOut)
      .onComplete(() => setTimeout(animateOut, 2000))
      .start();
  }

  function animateOut() {
    new TWEEN.Tween(smallHeart.position)
      .to({ x: 3.0, y: 3.0, z: 0.3 }, 1500)
      .easing(TWEEN.Easing.Quadratic.In)
      .onComplete(() => setTimeout(animateIn, 1500))
      .start();
  }

  animateIn();

  // Optional: center coreGroup nicely
  centerGroup(coreGroup);
});

// ---------- Helpers ----------
function centerGroup(group) {
  const box = new THREE.Box3().setFromObject(group);
  const center = new THREE.Vector3();
  box.getCenter(center);
  group.position.sub(center); // move to origin for nice framing
}

// ---------- Render Loop ----------
function animate() {
  requestAnimationFrame(animate);
  TWEEN.update();
  renderer.render(scene, camera);
}
animate();

// ---------- Resize ----------
addEventListener("resize", () => {
  camera.aspect = innerWidth / innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});
</script>
</body>
</html>
